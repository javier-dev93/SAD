---
title: "PEC 3"
author: "Alba Machado López - Javier Pueyo Aina"
date: "25/5/2021"
output:
  html_document:
    toc: yes
    toc_depth: 2
    number_sections: no
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{css, echo=FALSE}
p {
  text-align: justify
}

p.caption {
  font-size: 0.9em;
  font-style: italic;
  color: grey;
  margin-right: 10%;
  margin-left: 0%;  
  text-align: justify;
}

h1 {
  font-size: 2em;
  color: SteelBlue;
  text-align: justify
}

h2 {
  font-size: 1.7em;
  color: SteelBlue;
  text-align: justify
}

h3 {
  font-size: 1.5em;
  color: SteelBlue;
  text-align: justify
}
.header-section-number::after {
  content: ".";
}
ol {
  font-size: 1em;
  color: SteelBlue;
  text-align: justify
}
```

# Sección 1

## Ejercicio 1

<span style="color: SteelBlue;">Buscad un conjunto de datos relacionados con la Bioestadística o Bioinformática. Para ello, podéis utilizar algunos recursos conocidos como es el caso de http://www.bioinformatics.org/sms2/index.html o de http://biostat.mc.vanderbilt.edu/wiki/Main/DataSets.  También podéis utilizar otros recursos propios que conozcáis o que sean de vuestro interés, y siempre teniendo en cuenta que sean datos públicos que podéis utilizar.  Tenéis que explicar la procedencia de los datos así como incluir las referencias que correspondan y justificar porqué habéis elegido estos datos.</span>

Existen numerosas opciones disponibles donde obtener conjuntos de datos, entre las que se encuentran, además de las mencionadas por el propio ejercicio, [kaggle](https://www.kaggle.com/) o [data.world](https://data.world/data-society/health-status-indicators). En nuestro caso, el conjunto de datos que hemos seleccionado proviene del [repositorio de Machine Learning UC Irvine](http://archive.ics.uci.edu/ml/index.php), que contiene una colección de conjuntos de datos públicos procedentes de distintas fuentes y que facilita, de un primer vistazo, identificar las características de los conjuntos de datos e incluso los tipos de análisis que se les podrían aplicar. 

A la hora de seleccionar un conjunto de datos, tratamos de buscar alguno que tuviera un buen número de registros y bastantes variables de todos los tipos (numéricas, categóricas, booleanas...) de modo que existieran muchas posibilidades a la hora de explorar los datos e intentar obtener conclusiones. Con respecto al tema, nos centramos en buscar conjuntos de datos relacionados con el campo de la oncología, ya que se trata de una disciplina en la que los dos tenemos cierta experiencia y nos permitirá comprender mejor los datos e interpretar los resultados de los análisis que realizaremos.

En base a estas características, encontramos el conjunto de datos que finalmente hemos seleccionado, llamado [Cervical cancer (Risk Factors) Data Set](http://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29). Este conjunto de datos contiene información demográfica, clínica y sobre hábitos de vida de mujeres tratadas en el Hospital Universitario de Caracas (Caracas, Venezuela). Más concretamente, este conjunto de datos se define en el capítulo _Transfer Learning with Partial Observability Applied to Cervical Cancer Screening_ [**1**], en el que se utiliza para evaluar una estrategia de aprendizaje por transferencia (*transfer learning*, utilizar un modelo pre-entrenado en un problema distinto al inicial) en la predicción de riesgo de cáncer de cervix.

A modo de introducción, el cáncer de cérvix (también llamado cáncer cervical o cáncer de cuello uterino) es el cuarto tipo de cáncer más común en mujeres, con tasas de mortalidad elevadas que varían según el país (en países desarrollados son menores debido a diferencias en el acceso a servicios de salud y hábitos de vida) [**2**]. 

Al inicio de la enfermedad, el cáncer de cérvix suele ser asintomático, aunque puede presentarse con sangrado excesivo y avanzar a dolor abdominal u otros síntomas. El diagnóstico de este tipo de cáncer comienza con la examinación de la paciente para detectar masas anormales, seguido de otras pruebas como la de Papanicolaou, la colposcopia o la examinación histopatológica de la biopsia. El tratamiento de esta enfermedad puede incluir quimioterapia, radioterapia e inmunoterapia, aunque en la mayoría de casos estos son tratamientos adyuvantes a una intervención quirúrgica [**3**].

Las tasas de éxito de estos tratamientos son variables, por lo que gran parte de los esfuerzos de la investigación científica en el cáncer de cervix se están centrando en su prevención y detección temprana. Es en estos casos en los que conjuntos de datos como el que se va a trabajar en esta PEC ganan relevancia, resaltando la utilidad de la bioinformática y la bioestadística como una herramienta de aplicación traslacional que pueda ser empleada en la práctica clínica. 


## Ejercicio 2

<span style="color: SteelBlue;">Utilizando R, mostrad y explicad qué tipo de fichero habéis importado y las variables que forman parte de él (tipo, clasificación,...), así como todo aquello que creáis relevante. Incluir capturas de pantalla y las instrucciones en R que habéis utilizado para importar y  mostrar los datos.</span>

Como se ha comentado en el ejercicio previo, el conjunto de datos que hemos elegido se ha obtenido de un repositorio, por lo que podemos utilizar la url directamente para descargar los datos. De todos modos, descargamos los datos para que se puedan cargar desde el archivo csv como se muestra en la siguiente captura por si en algún momento no funcionara el enlace.

![Desgarga del conjunto de datos en formato csv](./images/ejercicio2.jpg "Desgarga del conjunto de datos en formato csv")

```{r}
# Descargamos el conjunto de datos utilizando la función read.csv y los argumentos header=T para indicar que la primera fila del archivo csv realmente corresponde a los nombres de las columnas (headers), stringsAsFactors=F para que no se conviertan los caracteres a factor y por último na.strings para indicar que lo que aparece como una interrogación realmente es un valor faltante (NA)
cervical_cancer <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/00383/risk_factors_cervical_cancer.csv",header=T, stringsAsFactors = F, na.strings="?")

# Si quisiéramos cargar el archivo csv descargado, utilizaríamos el mismo comando, pero sustituyendo la url del enlace por la ruta al archivo
```

Lo primero que hacemos es mostrar los primeros y últimos registros para hacernos una idea general del conjunto de datos, usando las funciones `head` y `tail` respectivamente. 

```{r}
# Mostramos los primeros registros
head(cervical_cancer)

# Y los últimos
tail(cervical_cancer)
```

Después, podemos ver las dimensiones del conjunto de datos usando la función `dim`
```{r}
dim(cervical_cancer)
```

Así, comprobamos que se trata de un conjunto de datos con dimensiones 858x36, es decir, con 858 filas o registros (en este caso datos de mujeres) y 36 columnas o variables.

Para conocer mejor las características del conjunto de datos podemos evaluar qué tipo de objeto es y la estructura general del conjunto de datos (para ver tanto el nombre de las variables como su tipo). 

```{r}
# También podemos comprobar qué tipo de objeto estamos utilizando
class(cervical_cancer)

# Y ver qué estructura tiene
str(cervical_cancer)
```

Así, nuestro objeto de trabajo es un data frame que contiene 36 variables. A priori, solo tenemos dos tipos de variables, `int`, es decir, números enteros y `num`, es decir, variables numéricas decimales. Realmente, muchas de estas variables solo pueden tomar dos valores (0 o 1) por lo que podríamos recodificarlas como factores. 

Una descripción un poco más detallada de las variables sería la siguiente:

-   Age: Edad (int)
-   Number.of.sexual.partners: Número de parejas sexuales (int)
-   First.sexual.intercourse: Edad a la que se tuvo la primera relación sexual
-   Num.of.pregnancies: Número de embarazos
-   Smokes: Mujer fumadora (sí o no)
-   Smokes..years.: Tiempo que la mujer es fumadora en años
-   Smokes..packs.year.: Número de paquetes de tabaco al año
-   Hormonal.Contraceptives: Uso de anticonceptivos hormonales (sí o no)
-   Hormonal.Contraceptives..years.: Tiempo de uso de anticonceptivos hormonales en años
-   IUD: Uso de dispositivo intrauterino o DIU (sí o no)
-   IUD..years.: Tiempo de Uso de DIU en años
-   STDs: Diagnóstico de enfermedades de transmisión sexual o ETS (sí o no)
-   STDs..number.: Número de ETS

Las siguientes variables son booleanas sobre si se ha detectado o no cada una de las ETS en específico:

  -   STDs.condylomatosis:
  -   STDs:cervical condylomatosis:
  -   STDs:vaginal condylomatosis
  -   STDs:vulvo-perineal condylomatosis
  -   STDs:syphilis
  -   STDs:pelvic inflammatory disease
  -   STDs:genital herpes
  -   STDs:molluscum contagiosum
  -   STDs:AIDS
  -   STDs:HIV
  -   STDs:Hepatitis B
  -   STDs:HPV
  
-   STDs: Number of diagnosis: Número de diagnósticos de ETS
-   STDs: Time since first diagnosis: Tiempo desde el primer diagnóstico de ETS
-   STDs: Time since last diagnosis: Tiempo desde el último diagnóstico de ETS
-   Dx.Cancer: Diagnóstico de cáncer (sí o no)
-   Dx.CIN: Diagnóstico de Neoplasia cervical intraepitelial (NCI, un cambio en las células uterinas que todavía no son malignas)
-   Dx.HPV: Diagnóstico de virus del papiloma humano, HPV (sí o no)
-   Dx: Paciente diagnosticada (sí o no)
-   Hinselmann: Diagnóstico por colposcopía (sí o no). Esta prueba utiliza un colposcopio, que funciona a modo de lupa para observar la morfología de las células del cuello del útero. 
-   Schiller: Diagnóstico por técnica de Schiller (sí o no). En esta prueba, durante la colposcopía se introduce una solución que tiñe las células del cérvix.
-   Citology: Diagnóstico por citología (sí o no). En esta prueba se realiza un raspado de las células cervicales para examinarlas. 
-   Biopsy:Diagnóstico por biopsia (sí o no). En esta prueba se toma un fragmento de tejido cervical para analizarlo utilizando técnicas de anatomía patológica. 

Procedemos a recodificar las variables como factores

```{r}
# Primero definimos un objeto con los nombres de las columnas que vamos a recodificar
columnas_booleanas <- c("Smokes","Hormonal.Contraceptives","IUD","STDs","STDs.condylomatosis","STDs.cervical.condylomatosis","STDs.vaginal.condylomatosis","STDs.vulvo.perineal.condylomatosis","STDs.syphilis","STDs.pelvic.inflammatory.disease","STDs.genital.herpes", "STDs.molluscum.contagiosum", "STDs.AIDS","STDs.HIV","STDs.Hepatitis.B","STDs.HPV", "Dx.Cancer","Dx.CIN","Dx.HPV","Dx","Hinselmann","Schiller","Citology","Biopsy")

# Creamos un for loop que itere sobre las columnas que hemos especificado, y las recodifique como factor, especificando los nuevos niveles
for (columna in columnas_booleanas){
  cervical_cancer[,columna] <- factor(cervical_cancer[,columna], levels=c(0,1),labels=c("No","Yes"))
}

# Mostramos los primeros registros del dataframe recodificado
head(cervical_cancer)
```


## Ejercicio 3

<span style="color: SteelBlue;"> Realizad un mínimo de seis preguntas objetivo que den una idea de la información contenida en el conjunto de datos escogido, es decir, obtener información del conjunto de datos a partir de determinados criterios, según variables, o rangos de valores, etc... Para ello, podéis basaros en el tipo de consultas realizadas en la PEC1 y también utilizando, en alguno de los casos, la definición de funciones tal como se trabaja en el LAB3.</span>

### Pregunta 1

En primer lugar, dado que los propios autores del dataset advierten que hubo pacientes que decidieron responder a algunas preguntas por cuestiones de privacidad, nos preguntamos ¿Cuántos valores faltantes (*missing values*) hay en el dataset? ¿Se concentran en alguna variable en concreto?

```{r}
# Utilizamos la función sapply para contar los valores TRUE (sum) de la función is.na (es decir, valores NA) sobre cada una de las columnas del dataset. Además utilizamos sort para ordenarlos de mayor a menor (indicado con decreasing=T)
sort(sapply(cervical_cancer, function(x) sum(is.na(x))), decreasing = T)

```

Como se puede observar, existe un número elevado de falores faltantes, especialmente en las variables `STDs..Time.since.first.diagnosis` y `STDs..Time.since.last.diagnosis`.
Sin embargo, como los propios autores indican [**1**], estos valores faltantes pueden "imputarse" usando la media muestral, ya que, aunque sería preferible tener los datos reales, es mejor que eliminar a una paciente del conjunto de datos sólo por tener valores faltantes en alguna de las variables. 

```{r}
# Primero definimos un nuevo objeto que contenga las columnas en las que podemos imputar los valores usando la media, es decir, las variables int o numéricas. Obtenemos estas variables eliminando del total de variables (es decir, los names del dataframe) aquellos que se encuentran dentro del objeto del ejercicio 1, columnas booleanas
columnas_numericas <- names(cervical_cancer)[!names(cervical_cancer) %in% columnas_booleanas]

# Definimos una función que consiste en aplicarle a un conjunto (el argumento "datos") un for loop que itera sobre cada una de las columnas del conjunto. 
# Para cada columna, se buscan los valores NA (usando como índice de fila is.na en esa columna y como índice de columna el nombre de la columna) y se sustituyen por la media de valores que hay en esa columna (mean, indicando que se eliminen los NA porque si no volveríamos a obtener un NA)
imputar_medias <- function(datos){
  for (columna in columnas_numericas)
  {datos[is.na(datos[,columna]), columna] <- mean(datos[,columna], na.rm = TRUE)}
  return(datos)} # Añadimos la función return para disponer del conjunto de datos modificado en todo el environment ya que si no se limitaría a la función

# Aplicamos la función sobre nuestro conjunto y la guardamos en un objeto con el mismo nombre para reemplazar el conjunto de datos original
cervical_cancer <- imputar_medias(cervical_cancer)

# Comprobamos que hemos elminado los missing values en la columna "STDs..Time.since.last.diagnosis" que era una de las variables numéricas que más NA tenía (no lo hacemos sobre el dataframe completo porque no hemos reemplazado los NAs en las variables categóricas)
cervical_cancer$STDs..Time.since.last.diagnosis[is.na(cervical_cancer$STDs..Time.since.last.diagnosis)]
```


### Pregunta 2

Después, es interesante conocer cuántas mujeres participaron en el estudio, así como la proporción de mujeres que fueron diagnosticadas finalmente con cáncer de cervix. 

```{r}
# Para contar el número de mujeres que participaron en el estudio simplemente tenemos que ver el tamaño del dataset (o su número de filas, nrow)
nrow(cervical_cancer)

# Para conocer el total de mujeres que fueron diagnosticadas finalmente con cáncer cervical sumamos solo aquellos valores que cumplen la condición Dx.cancer=Yes
sum(cervical_cancer$Dx.Cancer=="Yes")

# Para calcular la proporción, dividimos el número de pacientes diagnosticadas con cancer y lo dividimos entre el total de pacientes, además de multiplicar por 100 para mostrarlo en porcentaje
100*sum(cervical_cancer$Dx.Cancer=="Yes")/nrow(cervical_cancer)
```

En este caso vemos que hay registros de 858 mujeres, de las cuales 18 fueron diagnosticadas con cáncer de cervix, es decir, un 2.10%.

### Pregunta 3

A la hora de hacer un estudio en cancer, la edad es una variable que tiene una gran relevancia, ya que las prevalencias pueden variar mucho según la edad de los pacientes. En el caso concreto del cáncer de cérvix, la mayoría de casos se diagnostican entre los 35 y los 44 años [**4**]. Por ello, sería útil conocer los valores mínimos y máximos de esta variable y ver las frecuencias según rangos de edad de, por ejemplo, 10 años

```{r}
# Obtenemos el máximo usando "max"
max(cervical_cancer$Age)

# Y el mínimo usando "min"
min(cervical_cancer$Age)

# Para evaluar la frecuencia por rangos de edad primero usamos la función cut que separa la variable Age según el argumento breaks, que definimos utilizando seq para obtener una secuencia de números entre 0 y 100 con un paso de 10. Finalmente utilizamos table para obtener la tabla de frecuencias.
table(cut(cervical_cancer$Age, breaks=seq(0, 100, 10)))
```

De este modo comprobamos que la paciente de mayor edad tuvo 84 años y la de menor 13. Además, vemos que la mayoría de nuestros datos se concentran entre los 10 y los 40 años.

### Pregunta 4

También relacionada con la edad, un factor importante en el cáncer de cervix es el estado menopáusico de la paciente. Si establecemos la edad a partir de la cual suele aparecer la menopausia (varía según la etnia, la establecemos en 49.7 años, que se corresponde con la edad media en Latinoamérica [**5**]) podemos definir una nueva columna "Menopause" que indique si la paciente es pre- o post-menopáusica.

```{r}
# Creamos la variable directamente (indicada con $). Utilizamos la función ifelse, en la que establecemos una condición (en este caso que la edad sea superior a 49.7) y las dos alternativas ("yes" si la condición se cumple y "no" si no se cumple)
cervical_cancer$Menopause <- ifelse(cervical_cancer$Age >=49.7, "Yes", "No")
```


### Pregunta 5

Se ha reportado que el herpesvirus es una de las causas más frecuentes de cáncer de cervix en humanos [**6**]. ¿En cuántas pacientes de las diagnosticadas con cáncer de cervix se detectó infección por este virus? ¿Qué proporción representa con respecto al total de mujeres diagnosticadas con cáncer de cervix?

```{r}
# Creamos un "subset" a partir de nuestro conjunto de datos, seleccionando las filas que cumplen las dos (indicado con el símbolo &) condiciones (Dx.cancer=1 y Dx.HPV=1). Después, para saber el total de pacientes que cumplen ambas condiciones solo necesitamos saber el número de filas del conjunto (nrow)
nrow(cervical_cancer[(cervical_cancer$Dx.Cancer=="Yes" & cervical_cancer$Dx.HPV=="Yes"),])

# Para calcular la proporción  dividimos el valor que acabamos de calcular entre el total de pacientes diagnosticadas con cáncer de cervix
nrow(cervical_cancer[(cervical_cancer$Dx.Cancer=="Yes" & cervical_cancer$Dx.HPV=="Yes"),])*100 / nrow(cervical_cancer[(cervical_cancer$Dx.Cancer=="Yes"),])
```

De este modo hemos comprobado que los datos concuerdan con lo reportado en la bibliografía, ya que 16 de las 18 pacientes diagnosticadas con cáncer cervical (un 88,89%) también fueron diagnosticadas con HPV.

### Pregunta 6

Finalmente, las cuatro últimas variables del dataset (Hinselmann, Schiller, Cytology y Biopsy) indican pruebas diagnósticas utilizadas frecuentemente en cáncer. Separando por pacientes diagnosticadas con cáncer, se podría crear un nuevo dataset solo con estas variables y añadiendo el número total de pruebas (entre 0 y 4).

```{r}
# Para crear un nuevo data.frame, especificamos las columnas que queremos que lo compongan, extrayéndolas directamente del dataframe original, especificando los nombres que queremos que tengan

pruebas_positivas <- data.frame("Diagnosis"=cervical_cancer$Dx.Cancer,"Hinselman"=cervical_cancer$Hinselmann,"Schiller"=cervical_cancer$Schiller,"Cytology"= cervical_cancer$Citology, "Biopsy"=cervical_cancer$Biopsy)

# La última columna, number_of_tests, la calculamos utilizando la función "rowSums" en las columnas 2 a 5 (excluimos la de diagnóstico final) cuando existe un valor "Yes"
pruebas_positivas$number_of_tests <- rowSums(pruebas_positivas[,2:5]=="Yes")

# Mostramos los primeros registros del dataframe que acabamos de crear:
head(pruebas_positivas)
```


## Ejercicio 4

<span style="color: SteelBlue;">Realizad un análisis descriptivo de los datos. Este estudio debe incluir, un resumen paramétrico de los datos y diversas representaciones gráficas de los mismos basadas en determinados criterios. Dejamos a vuestra elección el tipo de gráficos y los criterios utilizados.</span>

En primer lugar, realizamos un resumen paramétrico de los datos usando la función `summary`:

```{r}
summary(cervical_cancer)
```

Esta función nos permite obtener, para cada variable numérica del conjunto, el mínimo, máximo, primer y tercer cuartil, media, mediana y número de NAs. Para las variables categóricas (que hemos recodificado anteriormente como factor) nos muestra el número de veces que aparece cada posible valor. Podríamos haber utilizado distintas funciones para calcular cada uno de estos valores por separado (`max`,`min`,`mean`,`median`...), pero gracias a `summary` obtenemos todos estos valores utilizando una sola función. Uno de los pocos parámetros que no nos proporciona esta función es la desviación estándar y la varianza, que calculamos usando `sd` y `var`, respectivamente. 

```{r}
# Utilizamos el mismo objeto que hemos creado en el ejercicio anterior que contiene los nombres de las columnas de tipo numérico o integer para aplicar (usando apply y con el argumento 2 para hacerlo a todas las columnas directamente) las funciones sd y var 

apply(cervical_cancer[columnas_numericas], 2, sd)

apply(cervical_cancer[columnas_numericas], 2, var)
```


Además de este resumen paramétrico, para conocer con más detenimiento algunas de las variables del conjunto de datos podemos realizar diversas representaciones gráficas, para lo que utilizaremos R base y el paquete `ggplot2`.

```{r}
library(ggplot2)
```


En primer lugar, y dada la importancia de la edad en este tipo de estudios que ya hemos comentado, podemos realizar un histograma de esta variable, añadiéndole la línea de densidad para ver cómo se distribuye.

```{r}
hist(cervical_cancer$Age, breaks=20, col="aquamarine1", xlab="Edad de las pacientes", ylab="Frecuencia",main="Histograma de edad",xlim=c(0,85),freq=F) # Cambiamos el número de intervalos y coloreamos el histograma de azul, además de añadir títulos a los ejes y al gráfico completo y cambiar los límites del eje x para que aparezca entero
lines(density(cervical_cancer$Age),col="aquamarine4",lwd=3)
```

En esta gráfica vemos que la distribución no es exactamente una distribución normal, si no que parece más sesgada hacia la izquierda, es decir, hay más pacientes de menores edades.

Por otro lado, para evaluar de un vistazo los datos de las pruebas diagnósticas así como el diagnóstico final, podemos representarlas todas estas variables a la vez utilizando un barplot agrupado:


```{r}
# Primero creamos un nuevo data frame al unir (cbind, por las columnas) las tablas de frecuencias que obtenemos para cada una de las variables de interés (table)
datos_Dx <- data.frame(cbind(table(cervical_cancer$Dx.Cancer),table(cervical_cancer$Dx.CIN),table(cervical_cancer$Dx.HPV),table(cervical_cancer$Hinselmann),table(cervical_cancer$Schiller),table(cervical_cancer$Citology),table(cervical_cancer$Biopsy)))

# Corregimos el nombre de las columnas del nuevo dataframe
colnames(datos_Dx) <- c("Dx.Cancer","Dx.CIN","Dx.HPV","Hinselmann","Schiller","Citology","Biopsy")

# Para hacer este tipo de gráfico, necesitamos que los datos estén en formato "long" (cada fila se corresponde a una observación de un conjunto de categorías) en lugar de en formato "wide" que es como los tenemos. Para ello usamos la función reshape (por continuar en R base y no necesitar paquetes adicionales) e indicamos el conjunto de datos a transformar, las variables que queremos que sean las categorías en el formato long y que combinamos en una nueva variable (Varing y times respectivamente), el nombre de la variable que se traslada desde el formato wide (count), la variable que diferencia las distintas observaciones (timevar), los identificadores de cada categoría (ids) y el formato al que queremos transformar (direction)
datos_Dx_long <- reshape(datos_Dx, 
  varying = c("Dx.Cancer","Dx.CIN","Dx.HPV","Hinselmann","Schiller","Citology","Biopsy"), 
  v.names = "count",
  timevar = "Diagnosis", 
  times = c("Dx.Cancer","Dx.CIN","Dx.HPV","Hinselmann","Schiller","Citology","Biopsy"),ids=c("No","Yes"),
  direction = "long")

# Mostramos los primeros registros del nuevo dataframe
head(datos_Dx_long)
```


```{r}
# Utilizamos ggplot para representar las variables. En este caso, en el eje y colocamos la variable Diagnosis, es decir, separando por tipo de prueba o diagnóstico. En el eje y representamos la variable "count" y con fill se representa la variable id, es decir, el número de veces que cada uno de los valores de la variable id (yes o no) aparece asociado a las categorías de Diagnosis
ggplot(datos_Dx_long, aes(fill=id, y=count, x=Diagnosis)) + 
    geom_bar(position="dodge", stat="identity") + # Utilizamos geom_bar para hacer el gráfico de barras, indicando que la posición sea "dodge" es decir, que las barras de cada categoría se muestren adyacentes en vez de apiladas o separadas.
  scale_fill_manual(values=c("darkseagreen","coral1")) +# Cambiamos los colores usando scale_fill_manual
  ylab("Count") + ggtitle("Proportion of yes/no for test/diagnosis")+ theme(legend.title = element_blank()) # Eliminamos el título de la leyenda porque no es informativo (reemplazamos el título (legend.title) por un elemento vacío (element_blank))


# Otra representación similar y también interesante sería utilizando el argumento position="fill" en el que se representan los valores en forma de proporción, para poder comparar entre variables
ggplot(datos_Dx_long, aes(fill=id, y=count, x=Diagnosis)) + 
    geom_bar(position="fill", stat="identity") + scale_fill_manual(values=c("darkseagreen","coral1")) + ylab("Frequency") + ggtitle("Proportion of yes/no for test/diagnosis") + theme(legend.title = element_blank()) 
```

De nuevo, en ambas representaciones podemos comprobar que tenemos un sesgo importante hacia el valor "no" en todas las variables de pruebas o diagnóstico, lo cual es importante tener en cuenta a la hora de interpretar los resultados. 

Dada la importancia del consumo de tabaco en el desarrollo de muchos tipos de cáncer, también estamos interesados en la distribución de los dos grupos según la edad de las pacientes. 

```{r}
# Indicamos las variables a representar en los ejes x e y, además de indicar que las cajas se coloreen según el valor de la variable Smokes (con fill). Añadimos geom_boxplot para que se represente como un diagrama de cajas y geom_jitter para representar también los puntos en concreto que han dado lugar a ese boxplot. También cambiamos el color usando scale_fill_manual 
ggplot(data=cervical_cancer, aes(x=Smokes,y=Age,fill=Smokes)) +
  geom_boxplot() + geom_jitter(width=0.1,alpha=0.1) + ggtitle("Edad de las pacientes fumadoras y no fumadoras") + scale_fill_manual(values = c("steelblue2", "royalblue3"))
```


Finalmente, para observar la relación entre dos variables numéricas, podemos realizar una representación en forma de dotplot, como haremos a modo de ejemplo para evaluar a simple vista si existe una relación entre la edad de la paciente y la edad a la que tuvo lugar el primer encuentro sexual, e identificar posibles variaciones que se relacionen con diferencias culturales entre generaciones.

```{r}
qplot(x=Age,y=First.sexual.intercourse, data=cervical_cancer, xlab="Edad", ylab="Edad a la primera relación sexual", colour=I("cadetblue")) + # Dentro de la función qplot especificamos las variables que queremos representar en los ejes x e y y el conjunto al que pertenecen, además añadimos títulos para ambos ejes y cambiamos el color con "colour". De nuevo debemos usar I() que indica que el objeto debe tratarse "tal cual" ya que si no se interpreta como un factor y no se selecciona el color correctamente.
ggtitle("Edad de la paciente y edad a la primera relación sexual") # Añadimos el título añadiendo "ggtitle"
```

Es difícil extraer conclusiones de esta gráfica ya que no existe ninguna tendencia clara sobre la relación entre estas dos variables. Si quisiéramos explorar más esta asociación, deberíamos realizar análisis adicionales. 

En general en este ejercicio hemos podido comprobar la utilidad de llevar a cabo un resumen estadístico y realizar algunas representaciones gráficas del conjunto de datos, ya que nos permite identificar a priori las relaciones entre las variables y sus características, así como plantear nuevas preguntas o análisis.


## Ejercicio 5

<span style="color: SteelBlue;">Realizad, basándoos en los conceptos trabajados en el LAB4 y PEC2, un mínimo de tres enunciados que respondan a una cuestión de probabilidad y un mínimo de un enunciado que corresponda a un breve modelo de simulación. En este caso, si vuestro conjunto de datos no propicia estos enunciados, podéis generar una o diversas distribuciones en base a unos parámetros determinados definidos por vosotros.</span>

### Pregunta 1 - Probabilidad.

Tenemos los siguientes datos:

De una población de 858 mujeres 18 fueron diagnosticadas de cancer de cervix, un 2,10%.

De las 18 mujeres diagnosticadas de cancer de cervix 16 fueron también diagnosticadas con HPV, es decir un 88,89%.

P(Mujer Cancer) = 0.0210
P(Mujer HPV/Mujer Cancer) = 0.8889

El teorema de la probabilidad total hace inferencia estadística sobre un suceso B, a partir del resultado de un suceso A.

Siendo A la probabilidad de que una mujer sea diagnosticada de cancer de cervix y el sueceso B la probabilidad de que sea diagnosticada de HPV.

Por lo tanto la probabilidad de una mujer sea diagnosticada de cancer y de HPV.

P(HPV) = P(HPV/Mujeres Cancer)· P(Mujeres Cancer) = 0.8889·0.0210

```{r}
p_hpv = 0.8889*0.0210
p_hpv
```

### Pregunta 2 - Probabilidad.

Si tenemos una población de 200 mujeres ¿cual es la probabilidad de que 2 mujeres diagnosticadas de cancer esten diagnosticadas de HPV?

Para obtener la probabilidad suponemos que la población sigue una distribución binomial.

```{r}
dbinom(3,200,p_hpv)
```

Mediante la función shadeDist de la librería fastGraph podemos dibujar las distribuciones, a la hora de dibujar la distribución la escala del eje x será de 20 mujeres, como veremos a partir de 10 mujeres la probabilidad tiende a cero.  

```{r}
if(!require(fastGraph)){
    install.packages('fastGraph', repos='http://cran.us.r-project.org')
    library(fastGraph)
}
```


```{r}
shadeDist( c(2,3), "dbinom",parm1=200,parm2=p_hpv, lower.tail=FALSE,xmin=0,
xmax=20,xtic=c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))
```


### Pregunta 3 - Probabilidad.

¿Cuál es la probabilidad de que mas de 10 mujeres sean diagnosticadas de cancer y estén diagnosticadas de HPV?

La probabilidad de encontrar más de 10 casos, será la probabilidad acumulada de encontrar más de 10
mujeres diagnosticadas de cancer y HPV. Tendríamos que calcular la probabilidad acumulada de X mujeres, donde X>10 (11,12,13,14,15…). Hemos elegido un tamaño de población de 20 ya que como hemos podido observar a partir de 10 mujeres la probabilidad tiende a cero.

```{r}
pbinom(10, size=20, prob=p_hpv, lower.tail=FALSE)
```

Mediante la función shadeDist de la librería fastGraph podemos dibujar las distribuciones.

```{r}
shadeDist( 10, "dbinom",parm1=200,parm2=p_hpv, lower.tail=FALSE,xmin=0,
xmax=20,xtic=c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))
```

Podemos ver que la probabilidad tiende a cero.

### Pregunta 4 - Simulación.

Realizamos una simulación 

Se realiza la hipótesis de que la probabilidad de una mujer a ser diagnosticada de cancer de cervix y que previamente esté diagnosticada de HPV

Vamos a realizar una simulación partiendo de los valores observados y las probabilidades calculadas en las preguntas anteriores.

Realizamos una simulación generando 1500 valores aleatorios suponiendo que para 858 mujeres observadas, hay una probabilidad de 0.0186669, de que estás sean diagnosticadas de cáncer y HPV.

Suponemos que se sigue un distribución binomial.

```{r}
set.seed(666666)
#Generamos 1500 valores aleatorios suponiendo que para 858 mujeres observadas,la probabilidad de que tengan cancer de cervix y HPV sea 0.0186669.
sample_1500 <- rbinom(1500,858,p_hpv)
```

Dibujamos el histograma.

```{r}
#Representamos el histograma para la distribución generada).
hist(sample_1500)
```

Creamos la función de densidad sobre el histograma.

```{r}
#Creamos el histograma con el argumento freq=F.
hist(sample_1500, freq = F)
#Creamos la función densidad sobre el histograma.
lines(density(sample_1500))
```

## Ejercicio 6

<span style="color: SteelBlue;">Realizad un breve análisis de regresión (lineal y múltiple) a partir de las variables que disponéis y utilizando el criterio que responda a alguna pregunta de interés que os hayáis planteado.</span>

Como ya se ha comentado, el diagnóstico de enfermedades de transmisión sexual (como el HPV) pueden ser de gran relevancia en el cáncer de cervix. Nos planteamos si, utilizando el resto de variables del conjunto (correspondientes principalmente a información sobre hábitos de vida) podemos crear un modelo que prediga el número de ETS que puede sufrir la paciente.

A la hora de realizar un análisis de regresión lineal tenemos que tener en cuenta que las variables a escoger tienen que ser continuas.

Analizamos las variables del dataset

```{r}
str(cervical_cancer)
```
Por lo tanto seleccionamos las variables dimensión continua del dataset.

-   Age: Edad (int)
-   Number.of.sexual.partners: Número de parejas sexuales (int)
-   First.sexual.intercourse: Edad a la que se tuvo la primera relación sexual
-   Num.of.pregnancies: Número de embarazos
-   Smokes..years.: Tiempo que la mujer es fumadora en años
-   Smokes..packs.year.: Número de paquetes de tabaco al año
-   Hormonal.Contraceptives..years.: Tiempo de uso de anticonceptivos hormonales en años
-   IUD..years.: Tiempo de Uso de DIU en años
-   STDs..number.: Número de ETS
-   STDs..Time.since.first.diagnosis
-   STDs..Time.since.last.diagnosis


```{r}
# Creamos el dataset con las variables de dimensión continua.
data_regresion <- data.frame(cervical_cancer$Age,cervical_cancer$Number.of.sexual.partners,cervical_cancer$First.sexual.intercourse,cervical_cancer$Num.of.pregnancies,cervical_cancer$Smokes..years,cervical_cancer$Smokes..packs.year,cervical_cancer$Hormonal.Contraceptives..years,cervical_cancer$IUD..years,cervical_cancer$STDs..number,cervical_cancer$STDs..Number.of.diagnosis,cervical_cancer$STDs..Time.since.first.diagnosis,cervical_cancer$STDs..Time.since.last.diagnosis
)

# Corregimos el nombre de las columnas del nuevo dataframe
colnames(data_regresion) <- c("Age","Number.of.sexual.partners","First.sexual.intercourse","Num.of.pregnancies","Smokes..years","Smokes..packs.year","Hormonal.Contraceptives..years","IUD..years","STDs..number","STDs..Number.of.diagnosis","STDs..Time.since.first.diagnosis","STDs..Time.since.last.diagnosis")

```

Inicialmente calculamos el coeficiente de correlación de Pearson para las distintas combinaciones.

```{r}
#Creamos la matriz de correlaciones de pearson, para ver si hay correlación entre las variables.
cor(x=data_regresion,method="pearson")
```


Analizando la matriz de coeficientes de pearson, tenemos que escoger el par de variables que tienen el coeficiente más cerca de 1. 

A partir de esta matriz comprobamos que las variables Age y Num.of.pregnancies tienen una buena correlación, por lo que trataremos de predecir el número de embarazos de una mujer, ya que podría ser información útil, no solo a nivel epidemiológico si no en relación al cáncer de cérvix, ya que muchas veces el cáncer de cervix se puede diagnosticar de forma incidental en revisiones ordinarias de mujeres embarazadas **[2]**.


```{r}
#Realizamos gráficos de dispersión de las variables Age y Num.of.pregnancies.
data_pairs <- data.frame(data_regresion$Age,data_regresion$Num.of.pregnancies)
pairs(data_pairs)
```


```{r}
#Creamos el modelo de regresión lineal.
RegLin=lm(formula=Age~Num.of.pregnancies,data=data_regresion)
summary(RegLin)
```
```{r}
#Representamos el diagrama de puntos y la linea de regresión
plot(cervical_cancer$Num.of.pregnancies,cervical_cancer$Age, xlab="Num.of.pregnancies", ylab="Age") 
#plot(cervical_cancer$Age,cervical_cancer$Num.of.pregnancies, xlab="Age", ylab="Num.of.pregnancies") 

abline(RegLin)
```


El modelo de regresión tiene una R-squared de 0.2768, tenemos un ajuste de un 27%, sería un coeficiente bajo. Si bien, tenemos algunos puntos lejos de la linea de regresión, la mayoría de los puntos tienen una distribución uniforme en las proximidades de la linea.

A continuación vamos a realizar el modelo de regresión múltiple, para los posibles predictores de Num.of.pregnancies.

```{r}
#Generamos el modelo de regresión múltiple
RegLinMul <- lm(cervical_cancer$Num.of.pregnancies~cervical_cancer$Age+cervical_cancer$Number.of.sexual.partners+cervical_cancer$First.sexual.intercourse+cervical_cancer$Smokes..years+cervical_cancer$Smokes..packs.year+cervical_cancer$Hormonal.Contraceptives..years+cervical_cancer$IUD..years+cervical_cancer$STDs..number+cervical_cancer$STDs..Number.of.diagnosis+cervical_cancer$STDs..Time.since.first.diagnosis+cervical_cancer$STDs..Time.since.last.diagnosis,data=cervical_cancer) 

summary(RegLinMul)
```

Hemos calculado los coeficientes de los predictores posibles, ahora entre todos ellos seleccionamos los mejores.

```{r}
step(object=RegLinMul,direction ="both", trace=1)
```

Calculados los mejores predictores, realizamos de nuevo el modelo de regresión sobre estos.

```{r}
RegLinMul_p <- lm(formula = cervical_cancer$Num.of.pregnancies ~ cervical_cancer$Age + cervical_cancer$First.sexual.intercourse, data = cervical_cancer)
summary(RegLinMul_p)
```

Podemos observar que el R-squared  0.3506, mejor respecto al cálculo anterior. Por lo tanto hemos mejorado el ajuste mediante la regresión lineal múltiple. Sin embargo, sigue tratándose de un ajuste bastante pobre, lo que nos indica que con los datos de los que disponemos, no tenemos información suficiente para predecir el número de embarazos con cierta seguridad. 
Esto puede deberse a que nos falta información sobre otras variables, y dada la cantidad de factores que pueden influir en el que una mujer se quede embarazada o no, se trataría de un análisis a gran escala que podría aun así  no dar buenos resultados de predicción, ya que muchas de las variables serían difíciles de monitorizar.

## Ejercicio 7

<span style="color: SteelBlue;">A partir del conjunto de datos que estáis trabajando, plantead un estudio ANOVA y desarrolladlo si, a partir del estudio previo, se cumplen las condiciones.</span>

Estudios previos han demostrado que existe una asociación entre la edad en la que ocurre la primera relación sexual y el riesgo de cáncer de cervix, posiblemente debido a una mayor probabilidad de infección temprana por HPV u otras ETS [**7**]. Procedemos a comprobar si existe una relación entre la edad a la que ocurre la primera relación sexual y la detección o no de ETS en nuestro conjunto de datos de trabajo. 

Realizamos primero algunas comprobaciones previas:
```{r}
# Creamos un nuevo dataframe que contenga solo las dos columnas que nos interesan (delante de la coma no ponemos nada porque queremos todas las filas)
cervical_data_anova <- cervical_cancer[,c("STDs","First.sexual.intercourse")]

# Mostramos las primeras filas del nuevo dataframe
head(cervical_data_anova)
```

```{r}
# Comprobamos cuántas observaciones tenemos para cada uno de los grupos
table(cervical_data_anova$STDs)

# También podemos ver la proporción usando prop.table sobre la tabla creada
prop.table(table(cervical_data_anova$STDs))
```

Como vemos en la tabla, existe un sesgo importante ya que de todas las pacientes disponibles, solo un 10% fueron diagnosticadas con alguna ETS, por lo que deberemos interpretar los resultados con cautela. 

```{r}
# Calculamos media y desviación estándar por cada grupo usando aggregate, que divide el conjunto de datos según un criterio especifico y le aplica la función (mean para la media y sd para la desviación estándar)
aggregate(First.sexual.intercourse~STDs,data=cervical_data_anova,FUN=mean)

aggregate(First.sexual.intercourse~STDs,data=cervical_data_anova,FUN=sd)
```

Podemos ver que parece haber una diferencia bastante pequeña entre la edad del primer encuentro sexual entre las pacientes que sí fueron diagnosticadas con alguna ETS y las que no, que es mayor en el primer grupo. Podemos realizar una representación gráfica para vez la distribución de los datos:

```{r}
# Usamos boxplot para crear un diagrama de cajas, cambiando las etiquetas de los ejes x e y y cambiando el color de la gráfica
boxplot(First.sexual.intercourse~STDs,data=cervical_data_anova, ylab="Edad en la primera relación sexual", xlab="Diagnóstico de ETS", col="darkturquoise")
```

Como ya podíamos ver en la comparación de medias, la diferencia entre ambos grupos parece muy sutil, aunque podemos continuar con el análisis para evaluar si esta diferencia puede ser considerada significativa. Antes de hacer el ANOVA debemos comprobar que las variables siguen una distribución normal y que tienen varianzas iguales (homocedasticidad).

-   Para la normalidad:

```{r}
# Primero hacemos una representación gráfica
par(mfrow=c(1,2)) # Establecemos un espacio con una fila y dos columnas para hacer las gráficas de peso para cada uno de los grupos

# Primero filtramos el dataset para quedarnos solo con las pacientes diagnosticadas con ETS y representamos el gráfico de cuartiles (qqnorm) y la recta
qqnorm(cervical_data_anova[cervical_data_anova$STDs=="Yes","First.sexual.intercourse"],main="Pacientes con ETS") 
qqline(cervical_data_anova[cervical_data_anova$STDs=="Yes","First.sexual.intercourse"])

# Hacemos lo mismo con las pacientes no diagnosticadas con ETS
qqnorm(cervical_data_anova[cervical_data_anova$STDs=="No","First.sexual.intercourse"],main="Pacientes sin ETS") 
qqline(cervical_data_anova[cervical_data_anova$STDs=="No","First.sexual.intercourse"]) 
```

Comprobamos la ormalidad con un test de Kolmogorov-Smirnov ya que tenemos más de 50 muestras por cada grupo. 

```{r}
# Cargamos la librería
library(nortest)

# Para aplicar el test de Kolmogorov-Smirnov (también llamado test de Lilliefors) utilizamos la función lillie.test, y la aplicamos a todo el conjunto de datos pero separando por grupo (cosa que hacemos utilizando la función by e indicando que la separación de grupos viene determinada por la variable smoke)
by(data=cervical_data_anova,INDICES = cervical_data_anova$STDs,FUN=function(x){lillie.test(cervical_data_anova$First.sexual.intercourse)})
```
Tanto en las gráficas, donde los residuos se alejan bastante de la recta de los cuartiles teóricos de una ditribución normal tanto como en el test de normalidad de Liliefors (p valor<0.01 rechazamos la hipótesis nula de que las variables tienen una distribución normal) podemos comprobar que nuestras variables no siguen una distribución normal. En base a estos resultados **no deberíamos continuar con el ANOVA** aunque continuamos a modo ilustrativo, conocedores de que los resultados que se desprendan del análisis no son confiables ya que no se cumplen las premisas necesarias. 

Si las variables siguieran una distribución normal, también sería necesario comprobar la homocedasticidad, es decir, si la varianza es constante entre los grupos utilizando el test de Fligner-Killen.

```{r}
fligner.test(First.sexual.intercourse~STDs,data=cervical_data_anova)
```
En este caso obtenemos un p-valor superior a 0.05 por lo que aceptamos la hipótesis de que las varianzas son constantes entre los dos grupos.

Una vez hechas las comprobaciones de normalidad y homocedasticidad podemos hacer el ANOVA:
```{r}
# Utilizamos la función aov para crear un modelo de análisis de varianza, que guardamos en un nuevo objeto. Especificamos las dos variables de comparación y el conjunto de datos del que proceden, además de indicar que se omitan los valores faltantes
cervical_anova <- aov(First.sexual.intercourse~STDs,data=cervical_data_anova, na.action=na.omit)

# Mostramos el resumen estadístico del test
summary(cervical_anova)
```

El test anova indicaría que no hay diferencias significativas (p valor 0.05) en la edad del primer encuentro sexual y las pacientes diagnosticadas o no con ETS. Sin embargo, como ya se ha comprobado a lo largo del ejercicio, no se trata de un análisis fiable ya que no se cumple el requisito de normalidad de variables para hacer el ANOVA, hay un sesgo importante en el número de pacientes que hay en cada grupo (muchas más pacientes no tienen diagnosticada ninguna ETS) y se trata de un conjunto de datos con un alto número de valores faltantes. 

## Ejercicio 8

<span style="color: SteelBlue;">A partir de los datos de origen y el estudio realizado, haced una valoración final. Para ello, podéis basaros en las siguientes preguntas: "disponemos de conclusiones finales?", "sería necesario hacer un análisis más avanzado?", "faltan datos para obtener otro tipo de información como...?",....</span>

En esta sección hemos trabajado con un conjunto de datos con un buen número de registros y bastantes variables a analizar. Sin embargo, hemos encontrado el problema de que al tratarse de información de pacientes que acudían al hospital, existe un gran sesgo hacia pacientes que finalmente no padecieron cáncer de cervix, lo que dificulta realizar el análisis estadístico  para extraer conclusiones concretas sobre esta enfermedad. De este modo, sería de gran utilidad e importancia aumentar el número de pacientes que sí fueron diagnosticadas con cáncer de cervix e intentar aproximarlo al número de pacientes sanas. Además, esto nos permitiría aproximar las distribuciones de las variables a una distribución normal gracias al teorema central del límite (TCL).

También hemos de tener en cuenta que existe un elevado número de _missing values_ debido a cuestiones de privacidad, sobre todo en lo que respecta a las enfermedades de transmisión sexual, lo que ha hecho que perdamos información o haya sido necesario imputar valores en algunos casos, posiblemente alterando el resultado final del análisis. Otro punto a mejorar del conjunto de datos sería especificar la información proporcionada sobre las técnicas de diagnóstico. Sabemos si las pruebas se realizaron o no, pero no tenemos datos sobre el resultado de la prueba en concreto. Por ejemplo, si hubiéramos tenido información histopatológica de la biopsia (número de mitosis por campo, porcentaje de necrosis...) podríamos haber incorporado estas variables al análisis de regresión o haberlas utilizado para el ANOVA, buscando valores límite que nos permitieran mejorar el diagnóstico o predecir el estado de una paciente y su prognosis.

Con respecto a los análisis de probabilidad y simulación, en esta PEC se ha mostrado un breve ejemplo de cómo, a partir de una "muestra" de la población general (este conjunto de datos como "representativo" de la población Venezolana en general, por ejemplo), podemos estimar la prevalencia/indicencia de una determinada condición, para tratar de evaluar la distribución de las variables y predecir el impacto o la frecuencia que podrían tener a nivel clínico.

Además, y dada la relevancia de otras disciplinas de la bioinformática en el estudio del cáncer, sería interesante incorporar a este conjunto de datos otras variables que proporcionaran información sobre las características a nivel genómico, transcriptómico o proteómico de las pacientes analizadas, como una fuente añadida de información que permita encontrar herramientas para el diagnóstico temprano del cánCer cervical. 


# Sección 2. Análisis cluster con R

En esta sección vamos a desarrollar un análisis cluster en R. Partimos del dataset de la sección 1, Cervical cancer (Risk Factors) Data Set.

La idea en la que se fundamenta en analisis cluster es la de poder obtener 2 clusters donde se agrupen las intancias de mujeres que tienen cancer de cervix en el cluster 1 y aquellas que no tienen en el cluster 2.

Tenemos que tener en cuenta que para aplicar técnicas de agrupamiento basadas en aprendizaje no supervisado las variables a considerar no tienen que estar etiquetadas y tienen que ser continuas.

Como nuevo proyecto en el que aplicar las técnicas de agrupamiento vamos a seleccionar una serie de variables de dimensión continua del dataset.

-   Age: Edad (int)
-   Number.of.sexual.partners: Número de parejas sexuales (int)
-   First.sexual.intercourse: Edad a la que se tuvo la primera relación sexual
-   Num.of.pregnancies: Número de embarazos
-   Smokes..years.: Tiempo que la mujer es fumadora en años
-   Smokes..packs.year.: Número de paquetes de tabaco al año
-   Hormonal.Contraceptives..years.: Tiempo de uso de anticonceptivos hormonales en años
-   IUD..years.: Tiempo de Uso de DIU en años
-   STDs..number.: Número de ETS
-   STDs..Time.since.first.diagnosis
-   STDs..Time.since.last.diagnosis

Dado que estas variables tienen distinta dimensión, habrá que realizar un escalado, por ejemplo, centrar las variables de forma que todas ellas tengan media 0 y desviación estándar 1.

Una vez tratados los datos, procederemos a aplicar distintas técnicas de clustering para lo que realizaremos el análisis de tres métodos.

- k vecinos más cercanos.
- Estrategia jerarquica aglomerativa.
- Estrategia jerarquica divisonal.

Primero hacemos la carga de librerías:

```{r}
 if(!require(cluster)){
    install.packages('cluster', repos='http://cran.us.r-project.org')
    library(cluster)
}
```

Realizamos el tratamiento previo de los datos:

```{r}
# Creamos el dataset con las variables de dimensión continua.
data_cluster <- data.frame(cervical_cancer$Age,cervical_cancer$Number.of.sexual.partners,cervical_cancer$First.sexual.intercourse,cervical_cancer$Num.of.pregnancies,cervical_cancer$Smokes..years,cervical_cancer$Smokes..packs.year,cervical_cancer$Hormonal.Contraceptives..years,cervical_cancer$IUD..years,cervical_cancer$STDs..number,cervical_cancer$STDs..Number.of.diagnosis,cervical_cancer$STDs..Time.since.first.diagnosis,cervical_cancer$STDs..Time.since.last.diagnosis
)
# Renombramos los campos.
names(data_cluster) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12")
```

Dimensiones de los datos.

```{r}
dim(data_cluster)
```

Estructura de los datos.

```{r}
str(data_cluster)
```

Realizamos un backup de los datos.

```{r}
# Backup datos
data_cluster_backup <- data_cluster
```

Comprobamos los atributos con valores vacíos.

```{r}
# Estadísticas de valores vacíos
colSums(is.na(data_cluster))
```

```{r}
# Estadísticas de valores ""
colSums(data_cluster=="")
```

```{r}
# Estadísticas de valores ?
colSums(data_cluster=="?")
```

Vamos a usar las 4 primeras variables.

```{r}
data_cluster <- data_cluster[,1:4]
```

Desordenamos los datos.

```{r}
set.seed(666)
data_random <- data_cluster[sample(nrow(data_cluster)),]
```

Vamos a usar como muestra para el modelo un subconjunto de los datos, 200 ejemplos.

```{r}
x <- data_random[1:200,]
```

Escalamos todas las variables numéricas. Cada variable ahora tendrá una media cero y una desviación estándar uno. Este escalado hará que la desviación estándar sea la unidad de medida en cada coordenada.

```{r}
x <- scale(x)
```
 
Desconocemos a priori el número optimo de clusters, vamos a probar con varios valores.

```{r}
d <- daisy(x) 
resultados <- rep(0, 10)
for (i in c(2,3,4,5,6,7,8,9,10))
{
  fit           <- kmeans(x, i)
  y_cluster     <- fit$cluster
  sk            <- silhouette(y_cluster, d)
  resultados[i] <- mean(sk[,3])
}

```

Mostramos en una gráfica los valores de las silueta media de cada prueba para averiguar que número de clusters es mejor.

```{r}
plot(2:10,resultados[2:10],type="o",col="blue",pch=0,xlab="Numbero de clusters",ylab="Silueta")
```

Podemos observar que los mejores valores se obtienen para k=2 y K=3.

Evaluamos el mejor número de clusters como aquel que ofrece la menor suma de los cuadrados de las distancias de los puntos de cada grupo con respecto a su centro, con la mayor separación entre centros de grupos.

El gráfico mostrará una estructura de brazo que muestra el codo y por lo tanto el número de grupos optimo.

```{r}
resultados <- rep(0, 10)
for (i in c(2,3,4,5,6,7,8,9,10))
{
  fit           <- kmeans(x, i)
  resultados[i] <- fit$tot.withinss
}
plot(2:10,resultados[2:10],type="o",col="blue",pch=0,xlab="Numbero de clusters",ylab="tot.tot.withinss")
```

No queda muy claro el “codo” en la curva, podría ser 3 o 5 clusters.

Ejecutamos la función kmeansruns que ejecuta el algoritmo kmeans con un conjunto de valores y selecciona el valor del número de clusters que mejor funcione de acuerdo a dos criterios la silueta media (“asw”) y Calinski-Harabasz (“ch”).

```{r}
library(fpc)

fit_ch  <- kmeansruns(x, krange = 1:10, criterion = "ch") 
fit_asw <- kmeansruns(x, krange = 1:10, criterion = "asw") 

fit_ch$bestk
```


```{r}
fit_asw$bestk
```

Evaluamos el mejor núnero de clusters en función Calinski-Harabasz.

```{r}
plot(1:10,fit_ch$crit,type="o",col="blue",pch=0,xlab="Numero de clusters",ylab="Criterio Calinski-Harabasz")
```

El mejor valor se obtiene para k=4.

Evaluamos el mejor número de clusters en función del criterio de la silueta media.

```{r}
plot(1:10,fit_asw$crit,type="o",col="blue",pch=0,xlab="Numero de clusters",ylab="Criterio silueta media")
```

El mejor valor se obtiene para k=3, aunque están muy cerca los valores de k=2 y k=4.

Por lo tanto, resumiento, según los criterios aplicados tenemos:

- Suma de los cuadrados de las distancias, 3 y 5 clusters.

- Calinski-Harabasz, 4 clusters.

- Silueta media, 2,3,4 clusters,

Aplicamos el algoritmo kmeans con 2, 4 y 8 clusters.

```{r}
fit2       <- kmeans(x, 2)
y_cluster2 <- fit2$cluster

fit4       <- kmeans(x, 4)
y_cluster4 <- fit4$cluster

fit8       <- kmeans(x, 8)
y_cluster8 <- fit8$cluster
```

Visualizamos los clusters con la función clusplot.

Gráfica 2 Clusters.

```{r}
clusplot(x, fit2$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
```

Gráfica 4 Clusters.

```{r}
clusplot(x, fit4$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
```

Gráfica 8 Clusters.

```{r}
clusplot(x, fit8$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
```

También podemos visualizar el resultado del proceso de agrupamiento con el siguiente código para el caso de 2 clusters.

```{r}
plot(x[y_cluster2==1,],col='blue', xlim=c(min(x[,1]), max(x[,1])), ylim=c(min(x[,2]), max(x[,2])))
points(x[y_cluster2==2,],col='red')
```

Para el caso de  4 clusters

```{r}
plot(x[y_cluster4==1,],col='blue', xlim=c(min(x[,1]), max(x[,1])), ylim=c(min(x[,2]), max(x[,2])))
points(x[y_cluster4==2,],col='red')
points(x[y_cluster4==3,],col='green')
points(x[y_cluster4==4,],col='black')
```

Finalmente para el caso de 8 clusters.

```{r}
plot(x[y_cluster8==1,],col='blue', xlim=c(min(x[,1]), max(x[,1])), ylim=c(min(x[,2]), max(x[,2])))
points(x[y_cluster8==2,],col='red')
points(x[y_cluster8==3,],col='green')
points(x[y_cluster8==4,],col='black')
points(x[y_cluster8==5,],col='yellow')
points(x[y_cluster8==6,],col='purple')
points(x[y_cluster8==7,],col='cyan')
points(x[y_cluster8==8,],col='orange')
```

Evaluamos la calidad de la agregación. Usamos la función silhouette, calcula la silueta de cada muestra.

```{r}
d  <- daisy(x) 
sk2 <- silhouette(y_cluster2, d)
sk4 <- silhouette(y_cluster4, d)
sk8 <- silhouette(y_cluster8, d)
```

La función silhouette devuelve para cada muestra, el cluster donde ha sido asignado, el cluster vecino y el valor de la silueta. Por lo tanto, calculando la media de la tercera columna podemos obtener una estimación de la calidad del agrupamiento.

```{r}
mean(sk2[,3])
```

```{r}
mean(sk4[,3])
```

```{r}
mean(sk8[,3])
```

Como se puede comprobar, agrupar con 2 cluster es mejor que en 4 o en 8.

Conclusiones:

Hemos probado el modelo varias veces con distintos número de registros, partiendo de 50 ejemplos hasta 200. También hemos aumentado el número de variables hasta el máximo de 12. En todos los casos no hemos conseguido mejorar el modelo.

La agrupación por kmeans en general da valores bajos de agregación 0.3331395, siendo los  mejores resultados para dos clusters k = 2. Hemos probado también para k=3 y hemos obtenido la misma calidad de agrupamiento que para k=2.

Conforme aumentamos el número de ejemplos a tratar, la mayoría de los ejemplos se clasifican en el cluster 2, 65%, mientras que el resto se clasifican en el cluster 1, 35%.

```{r}
sum(sk2[,2]==1)
```

```{r}
sum(sk2[,2]==2)
```

También se puede observar que la calidad de la agregación va disminuyendo conforme aumentan los ejemplos que tratamos, en todos los casos siempre la agrupación con 2 y 3 cluster da mejor resultados. 


- Estrategia Jerárquica

La estrategía jerárquica consiste en, dados ejemplos sin etiquetar descritos por valores de atributos, obtener una jerarquía de clases que incluya cada una a un subconjunto de los ejemplos de entrenamiento.

Estas jerarquías se denominan dendogramas, donde cada nodo representa una clase de observaciones.

Las entradas son un conjunto de ejemplos de entrenamiento descritos por un conjunto de atributos y sus valores respectivos. La salida es una jerarquía de clases (dendograma).

Estas estrategias se dividen en dos métodos, aglomerativa y divisional.

- Estrategia Aglomerativa.

A cada observación se le asigna a su propio cluster, seguidamente se calcula la similitud entre cada uno de los clusters. Los clusters más similares se fusionan en uno; se repiten los pasos hasta que solo quede uno.

La función dist calcula los valores de la distancia, el método que vamos a usar es la distancia euclidea.

```{r}
# Cálculo de los valores de la distancia.
d <- dist(x, method = "euclidean")
```

La función hclust calcula el agrupamiento jerarquico aglomerativo, requiere la distancia y el método de vinculación.

```{r}
# Calculamos el agrupamiento jerárquico aglomerativo.
hc1 <- hclust(d, method = "complete" )
```

Gráfico del dendograma.

```{r}
# Gráfico del dendograma
plot(hc1, cex = 0.6, hang = -1)
```


La función agnes calcula el coeficiente de aglomeración, que mide la estructura de agrupamiento encontrada.

```{r}
hc2 <- agnes(x, method = "complete")
# Coeficiente de aglomeración.
hc2$ac
```

Valores cercanos a 1 establecen una estructura de agrupamiento fuerte.

La función `cutree` asigna clusters a los puntos dados.

```{r}
clust <- cutree(hc2, k = 2)
```

Cargamos libreria `factoextra`

```{r}

if(!require(factoextra)){
    install.packages('factoextra', repos='http://cran.us.r-project.org')
    library(factoextra)
}
```


Gráfico del diagrama de dispersión.

```{r}
fviz_cluster(list(data = x, cluster = clust))  ## from ‘factoextra’ package
```

- Estrategia Divisional

Todas las observaciones pertenecen a un grupo, seguidamente se divide el cluster en dos grupos menos similares. Esto se repite recursivamente en cada grupo hasta que haya solo un grupo para cada observación.

La función diana calcula el coeficiente de división, que mide la estructura de división encontrada.

```{r}
hc4 <- diana(x)
# Coeficiente de división.
hc4$dc
```

Valores cercanos a 1 establecen una estructura de división fuerte.

Gráfico del dendograma.

```{r}
# Gráfico del dendograma.
pltree(hc4, cex = 0.6, hang = -1, main = "Dendrogram of diana")
```

La función cutree asigna clusters a los puntos dados.

```{r}
clust <- cutree(hc4, k = 2)
```

Gráfico del diagrama de dispersión.

```{r}
fviz_cluster(list(data = x, cluster = clust))  ## from ‘factoextra’ package
```

Conclusiones:

Tanto la estrategia aglomerativa como la divisional dan buenos resultados, según sus coeficientes.

Coeficiente de aglomeración = 0,95 Coeficiente de división = 0,95

Comparando kmeans y las dos estrategias jerarquicas, podemos observar que los valores en kmeans se distribuyen en los 2 clusters, donde cluster 1 tiene 35% de los valores y el cluster 2 tiene el 65% En las estrategias jerárquicas practicamente la totalidad de los valores se situan en el cluster 1.

Por lo tanto kmeans particiona mejor las intancias, seguidamente la estrategia jerarquica divisional y aglomerativa dan resultados muy similares, como se puede comprobar en el gráfico. Estas estrategias jerarquicas no nos valdrían para realizar una agrupación de las intancias.

Con la agrupación que hemos obtenido de kmeans no podemos establecer una correlación entre los 2 clusters y el cancer de cervix o HPV, podemos ver que los clusters en los cuales se dividen las instancias tienen una distribución de valores que no concuerdan con los 2 cluster teóricos en los que se tendría que dividir las intancias. Tras realizar varias pruebas, ni aumentando el número de variables ni el de instancias hemos podido mejorar el modelo.

Una posibilidad que se podría plantear en el estudio de un análisis clustering, sería realizar la conversión de la variables discretas a continuas, estudiar las variables y ejecutar de nuevo el modelo, sin embargo al ser las variables discretas booleanas, no parece a priori que vayamos a mejorar los resultados del modelo.

Por lo tanto podemos conlcluir que necesitariamos más datos de dimensión continua que tuvieran alguna correlación significativa con el diagnostico cancer de cervix y HPV para que el modelo de análisis de cluster nos de buenos resultados.


# Referencias

-  **[1]**: Fernandes, K., Cardoso, J.S., Fernandes, J. (2017) Transfer Learning with Partial Observability Applied to Cervical Cancer Screening. In: Alexandre L., Salvador Sánchez J., Rodrigues J. (eds) _Pattern Recognition and Image Analysis_. IbPRIA 2017. Lecture Notes in Computer Science, vol 10255. Springer, Cham. https://doi.org/10.1007/978-3-319-58838-4_27

- **[2]**: Buskwofie, A., David-West, G., & Clare, C. A. (2020). A Review of Cervical Cancer: Incidence and Disparities. _Journal of the National Medical Association_, 112(2), 229–232. https://doi.org/10.1016/j.jnma.2020.03.002 

- **[3]**: Johnson, C. A., James, D., Marzan, A., & Armaos, M. (2019). Cervical Cancer: An Overview of Pathophysiology and Management. _Seminars in oncology nursing_, 35(2), 166–174. https://doi.org/10.1016/j.soncn.2019.02.003

- **[4]**: Siegel, R. L., Miller, K. D., Fuchs, H. E., & Jemal, A. (2021). Cancer Statistics, 2021. _CA: a cancer journal for clinicians_, 71(1), 7–33. https://doi.org/10.3322/caac.21654

- [**5**]: Castelo-Branco, C., Blümel, J. E., Chedraui, P., Calle, A., Bocanera, R., Depiano, E., Figueroa-Casas, P., Gonzalez, C., Martino, M., Royer, M., Zuñiga, C., Dulon, A., Espinoza, M. T., Futchner, C., Mostajo, D., Soto, E., Albernaz, M. A., Aravena, H., Busquets, M., Campodonico, I., … Figueroa-Casas, P. (2006). Age at menopause in Latin America. _Menopause_ (New York, N.Y.), 13(4), 706–712. https://doi.org/10.1097/01.gme.0000227338.73738.2d

- [**6**]: Bedell, S. L., Goldstein, L. S., Goldstein, A. R., & Goldstein, A. T. (2020). Cervical Cancer Screening: Past, Present, and Future. _Sexual medicine reviews_, 8(1), 28–37. https://doi.org/10.1016/j.sxmr.2019.09.005

- [**7**]: Plummer, M., Peto, J., Franceschi, S., & International Collaboration of Epidemiological Studies of Cervical Cancer (2012). Time since first sexual intercourse and the risk of cervical cancer. _International journal of cancer_, 130(11), 2638–2644. https://doi.org/10.1002/ijc.26250